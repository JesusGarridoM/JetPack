--- client.py.orig	2018-09-19 04:11:26.000000000 -0500
+++ client.py	2019-01-08 14:38:44.128836000 -0600

@@ -16,6 +16,7 @@
 """
 
 import logging
+import subprocess
 import time
 
 from dracclient import constants
@@ -243,6 +244,103 @@
         """
         return self._idrac_cfg.set_idrac_settings(settings, idrac_fqdd)
 
+    def reset_idrac(self, force=False, wait=False,
+                    ready_wait_time=30):
+        """Resets the iDRAC and optionally block until reset is complete.
+
+        :param force: does a force reset when True and a graceful reset when
+               False
+        :param wait: returns immediately after reset if False, or waits
+                for the iDRAC to return to operational state if True
+        :param ready_wait_time: the amount of time in seconds to wait after
+                the reset before starting to check on the iDRAC's status
+        :returns: True on success, raises exception on failure
+        :raises: WSManRequestFailure on request failures
+        :raises: WSManInvalidResponse when receiving invalid response
+        :raises: DRACOperationFailed on failure to reset iDRAC
+        """
+        return_value = self._idrac_cfg.reset_idrac(force)
+        if not wait and return_value:
+            return return_value
+
+        if not return_value:
+            raise exceptions.DRACOperationFailed(
+                drac_messages="Failed to reset iDRAC")
+
+        LOG.debug("iDRAC was reset, waiting for return to operational state")
+
+        state_reached = self._wait_for_host_state(
+            self.client.host,
+            alive=False,
+            ping_count=3,
+            retries=24)
+
+        if not state_reached:
+            raise exceptions.DRACOperationFailed(
+                drac_messages="Timed out waiting for the %s iDRAC to become "
+                "not pingable" % self.client.host)
+
+        LOG.info("The iDRAC has become not pingable")
+
+        state_reached = self._wait_for_host_state(
+            self.client.host,
+            alive=True,
+            ping_count=3,
+            retries=24)
+
+        if not state_reached:
+            raise exceptions.DRACOperationFailed(
+                drac_messages="Timed out waiting for the %s iDRAC to become "
+                "pingable" % self.client.host)
+
+        LOG.info("The iDRAC has become pingable")
+        LOG.info("Waiting for the iDRAC to become ready")
+        time.sleep(ready_wait_time)
+
+        self.client.wait_until_idrac_is_ready()
+
+    def _ping_host(self, host):
+        response = subprocess.call(
+            "ping -c 1 {} 2>&1 1>/dev/null".format(host), shell=True)
+        return (response == 0)
+
+    def _wait_for_host_state(self,
+                             host,
+                             alive=True,
+                             ping_count=3,
+                             retries=24):
+        if alive:
+            ping_type = "pingable"
+
+        else:
+            ping_type = "not pingable"
+
+        LOG.info("Waiting for the iDRAC to become %s", ping_type)
+
+        response_count = 0
+        state_reached = False
+
+        while retries > 0 and not state_reached:
+            response = self._ping_host(host)
+            retries -= 1
+            if response == alive:
+                response_count += 1
+                LOG.debug("The iDRAC is %s, count=%s",
+                          ping_type,
+                          response_count)
+                if response_count == ping_count:
+                    LOG.debug("Reached specified ping count")
+                    state_reached = True
+            else:
+                response_count = 0
+                if alive:
+                    LOG.debug("The iDRAC is still not pingable")
+                else:
+                    LOG.debug("The iDRAC is still pingable")
+            time.sleep(10)
+
+        return state_reached
+
     def commit_pending_idrac_changes(
             self,
             idrac_fqdd=IDRAC_FQDD,
@@ -687,7 +785,7 @@
         return self._raid_mgmt.delete_virtual_disk(virtual_disk)
 
     def commit_pending_raid_changes(self, raid_controller, reboot=False,
-                                    start_time='TIME_NOW'):
+                                    start_time='TIME_NOW', realtime=False):
         """Applies all pending changes on a RAID controller
 
          ...by creating a config job.
@@ -713,7 +811,8 @@
             cim_name='DCIM:RAIDService',
             target=raid_controller,
             reboot=reboot,
-            start_time=start_time)
+            start_time=start_time,
+            realtime=realtime)
 
     def abandon_pending_raid_changes(self, raid_controller):
         """Deletes all pending changes on a RAID controller
@@ -864,6 +963,61 @@
         """
         return self._raid_mgmt.is_jbod_capable(raid_controller_fqdd)
 
+    def is_raid_controller(self, raid_controller_fqdd):
+        """Find out if object's fqdd is for a raid controller or not
+    
+        :param raid_controller_fqdd: The object's fqdd we are testing to see
+                                     if it is a raid controller or not.
+        :returns: boolean, True if the device is a RAID controller,
+                  False if not.
+        """
+        return self._raid_mgmt.is_raid_controller(raid_controller_fqdd)
+    
+    def is_boss_controller(self, raid_controller_fqdd):
+        """Find out if a RAID controller a BOSS card or not
+    
+        :param raid_controller_fqdd: The object's fqdd we are testing to see
+                                     if it is a BOSS card or not.
+        :returns: boolean, True if the device is a BOSS card, False if not.
+        """
+        return self._raid_mgmt.is_boss_controller(raid_controller_fqdd)
+    
+    def change_physical_disk_state(self, mode,
+                                   controllers_to_physical_disk_ids=None):
+        """Convert disks RAID status and return a list of controller IDs
+    
+        Builds a list of controller ids that have had disks converted to the
+        specified RAID status by:
+        - Examining all the disks in the system and filtering out any that are
+          not attached to a RAID/BOSS controller.
+        - Inspect the controllers' disks to see if there are any that need to
+          be converted, if so convert them. If a disk is already in the desired
+          status the disk is ignored. Also check for failed or unknown disk
+          statuses and raise an exception where appropriate.
+        - Return a list of controller IDs for controllers whom have had any of
+          their disks converted, and whether a reboot is required.
+    
+        The caller typically should then create a config job for the list of
+        controllers returned to finalize the RAID configuration.
+    
+        :param mode: constants.RaidStatus enumeration used to determine what
+                     raid status to check for.
+        :param controllers_to_physical_disk_ids: Dictionary of controllers and
+               corresponding disk ids we are inspecting and creating jobs for
+               when needed.
+        :returns: a dict containing the following key/values:
+                  - is_reboot_required, a boolean stating whether a reboot is
+                  required or not.
+                  - commit_required_ids, a list of controller ids that will
+                  need to commit their pending RAID changes via a config job.
+        :raises: DRACOperationFailed on error reported back by the DRAC and the
+                 exception message does not contain NOT_SUPPORTED_MSG constant.
+        :raises: Exception on unknown error.
+        """
+        return (self._raid_mgmt
+                .change_physical_disk_state(mode,
+                                            controllers_to_physical_disk_ids))
+
 
 class WSManClient(wsman.Client):
     """Wrapper for wsman.Client that can wait until iDRAC is ready
